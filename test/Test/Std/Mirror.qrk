module Test.Std.Mirror for ReflectTest, MetaTest

import Std.Test for Case
import Std.Mirror for Reflect, Meta

class ReflectFixture {
  
  construct new(a) {
    this.a = a
  }

  construct defaults() {
    this.new('a')
  }

}

class ReflectTest : Case {

  construct new() {
    super.new()
  }
  
  @test('Gets the correct type name')
  testGetType() {
    this.assertEquals(Reflect.getClassName(ReflectTest), 'Test.Std.Mirror.ReflectTest');
  }

  @test('Compares classes correctly')
  testIs() {
    this.assertTrue(Reflect.is(ReflectTest, ReflectTest));
    this.assertTrue(Reflect.is(ReflectTest, Case));
    this.assertFalse(Reflect.is(ReflectTest, String));
  }

  @test('Gets constructor names')
  testGetConstructors() {
    this.assertEquals(
      Reflect.getConstructorNames(ReflectFixture).join(','),
      'new,defaults'
    ) 
  }

  @test('Calls constructors correctly')
  testCallConstructors() {
    var def = Reflect.getConstructor(ReflectFixture, 'defaults')
    this.assertEquals(def().a, 'a')
    this.assertTrue(Reflect.is(def(), ReflectFixture))
    
    var nu = Reflect.getConstructor(ReflectFixture, 'new')
    this.assertEquals(nu('b').a, 'b')
    this.assertTrue(Reflect.is(nu('b'), ReflectFixture))
  }

}

@foo
@bar('value')
class MetaFixture {
  
}

class MetaTest : Case {
  
  construct new() {
    super.new()
  }

  @test('Gets metadata for types')
  testTypeMeta() {
    Meta.getType(MetaFixture).forEach {
      if (it.name == 'foo') {
        this.assertEquals(it.values.length, 0)
      } else {
        this.assertEquals(it.name, 'bar')
        this.assertEquals(it.values[0], 'value')
      }
    }
  }

}

module Std.Test for
  Runner,
  Result,
  Status,
  Case

import Std.Core for System 
import Std.Mirror for Reflect, Meta

class Runner {

  construct new() {
    #result = Result.new()
    #cases = []
  }

  add(c) {
    #cases.push(c)
    return this
  }

  print(value) {
    System.print(value)
  }

  run() {
    #result = Result.new()
    #cases.forEach { this.runCase(it) }
    this.print(#result.toString())
    return #result.wasSuccessful()
  }

  runCase(c) {
    var className = Reflect.getClassName(c)
    var meta = Meta.getFields(c)
    var before = this.getBeforeMethods(c)
    var after = this.getAfterMethods(c)

    this.print('Class: ' + className + ' ')

    Reflect.getFieldNames(meta).forEach { | methodName |
      var method = Reflect.getMethod(c, methodName)
      var testMeta = meta[methodName].filter { it.name == 'test' }

      testMeta.forEach {
        var testInfo = it.values
        var label = '';
        if (testInfo.length > 0) {
          label = testInfo.join('\n')
        }

        c.currentTest = Status.new(className, methodName)
        before.forEach { it() }

        try {
          method()
          if (c.currentTest.done) {
            c.currentTest.success = true
            this.print('.')
          } else {
            c.currentTest.success = false
            c.currentTest.error = "(warning) no assert"
            this.print('W')
          }
        } catch (e) {
          this.print('E')
          if (Reflect.getClassName(e) == Reflect.getClassName(Status)) {
            e = e.error
          }
          c.currentTest.error = "exception thrown: " + e +
            '\n' + label
        }

        after.forEach { it() }
        #result.add(c.currentTest)
      }
    }

    this.print('\n')
  }

  getBeforeMethods(c) {
    return this.getMarkedMethods(c, 'before')
  }

  getAfterMethods(c) {
    return this.getMarkedMethods(c, 'after')
  }

  getMarkedMethods(c, name) {
    var marked = [];
    var meta = Meta.getFields(c)
    Reflect.getFieldNames(meta).forEach { | methodName |
      if (meta[methodName].filter { it.name == name }.length > 0) {
        marked.push(Reflect.getMethod(c, methodName))
      }
    }
    return marked
  }

}

class Result {

  construct new() {
    #tests = []
    #failures = 0
    #success = true
  }

  add(status) {
    #tests.push(status)
    if (status.success == false) {
      #success = false
    }
  }

  wasSuccessful() {
    return #success
  }

  toString() {
    var out = ""
    for (var i = 0; i < #tests.length; i = i + 1) {
      var test = #tests[i]
      if (test.success == false) {
        out = out + "* " + test.className + "::" + test.methodName + "()\n"
        out = out + "ERR: " + test.error + "\n"
        #failures = #failures + 1
      }
    }

    out = out + "\n"
    if (#failures == 0) {
      out = out + 'OK '
    } else {
      out = out + 'FAILED '
    }
    out = out + #tests.length + ' tests, ' +
      #failures + ' failed, ' +
      (#tests.length - #failures) + ' success \n'

    return out
  }

}

class Status {

  construct new(className, methodName) {
    #className = className
    #methodName = methodName
    #success = false
    #error = null
    #done = false
  }

  className { #className }
  methodName { #methodName }
  
  success { #success }
  success = value { #success = value }

  error { #error }
  error = value { #error = value }

  done { #done }

  markDone() {
    #done = true
  }

}

class Case {

  construct new() {
    #currentTest = Status.new(Reflect.getClassName(this), null)
  }

  currentTest { #currentTest }
  currentTest = value { #currentTest = value }

  assertTrue(value) {
    #currentTest.markDone()
    if (value != true) {
      #currentTest.success = false
      #currentTest.error = "Expected true but was false"
      throw #currentTest
    }
  }

  assertFalse(value) {
    #currentTest.markDone()
    if (value != false) {
      #currentTest.success = false
      #currentTest.error = "Expected false but was true"
      throw #currentTest
    }
  }

  assertEquals(actual, expected) {
    #currentTest.markDone()
    if (expected != actual) {
      #currentTest.success = false
      #currentTest.error = "Expected '" + expected + "' but was '" + actual + "'"
      throw #currentTest
    }
  }

}

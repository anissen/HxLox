module global for __quirk

/// Helpers used by Quirk to make things work. This must come
/// before anything else in this file.
@core
class __quirk {

  static env {
    if (#env == null) {
      #env = Environment.new()
    }
    return #env
  }

  static classes {
    if (#classes == null) {
      #classes = {}
    }
    return #classes
  }

  static meta {
    if (#meta == null) {
      #meta = {}
    }
    return #meta
  }
  
  static extend(obj, superclass) {
    obj.prototype = Object.create(superclass.prototype)
    return obj
  }

  static addClass(name, cls, constructors) {
    this.classes[name] = {
      type: cls,
      constructors: constructors
    }
  }

  static getClass(name) {
    var entry = this.classes[name]
    if (entry != null) return entry.type
    return null
  }

  static getConstructors(name) {
    return this.classes[name].constructors
  }

  static addMeta(target, meta) {
    this.meta[target.__name] = meta
  }

}

/// The Environment class is used to create a lightweight
/// CJS-like environment.
@core
class Environment {
  
  construct new() {
    #modules = {}
  }

  modules { #modules }

  define(name, deps, factory) {
    var mod = Module.new(this, deps, factory)
    #modules[name] = mod
    return mod
  }
  
  loadModules(deps, next) {
    var progress = deps.length
    if (next == null) {
      next = {
        return null
      }
    }

    // Keep running till progress == 0
    var onReady = { |err| 
      if (err) {
        next(err)
        return
      }

      progress = progress - 1
      if (progress <= 0) {
        next(null)
      }
    }
    
    deps.forEach {
      var mod = #modules[it]
      if (mod) {
        mod.onReady(onReady)
        mod.enable()
      } else {
        onReady('No module found for ' + dep)
      }
    }
  }
  
  main(name) {
    this.loadModules([ name ]) { |err|
      if (err != null) console.error(err)
    }
  }

}

@core
enum ModuleState {
  Disabled = "Disabled"
  Pending = "Pending"
  Enabling = "Enabling"
  Ready = "Ready"
}

@core
class Module {
  
  construct new(env, deps, factory) {
    #env = env
    #deps = deps
    #exports = {}
    #factory = {
      factory({ this.require(it) }, this, #exports)
    }
    #state = ModuleState.Pending
    #onReadyListeners = []
    #onFailedListeners = []
  }
  
  exports { #exports }
  exports = value { #exports = value }

  require(dep) {
    return #env.modules[dep].exports
  }
  
  onReady(cb) {
    if (#state == ModuleState.Ready) {
      cb()
      if (#onReadyListeners.length > 0) {
        this.dispatchListeners(#onReadyListeners)
      }
      return this
    }
    #onReadyListeners.push(cb)
    return this
  }
  
  onFailed (cb) {
    if (#state == ModuleState.Disabled) {
      cb()
      if (#onFailedListeners.length > 0) {
        this.dispatchListeners(#onFailedListeners)
      }
      return this
    }
    #onFailedListeners.push(cb)
    return this
  }
  
  dispatchListeners(listeners) {
    var cb
    while (cb = listeners.pop()) {
      cb()
    }
    return this
  }

  enable() {
    if (#state != ModuleState.Pending) {
      return this
    }
    #state = ModuleState.Enabling
    var finish = {
      #factory()
      #state = ModuleState.Ready
      this.dispatchListeners(#onReadyListeners)
    }
    if (#deps.length == 0) {
      finish()
    } else {
      #env.loadModules(#deps) { |err|
        if (err != null) {
          #state = ModuleState.Disabled
          this.dispatchListeners(#onFailedListeners)
          return
        }
        finish()
      }
    }
  }

}

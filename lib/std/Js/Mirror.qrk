module Std.Mirror for Reflect, Meta

var _toString = ({}).toString

/// `Reflect` implementation for the js target. This depends on
/// the `lib/js-lib.js` file to work.
class Reflect {
  
  static getClass(target) {
    return __quirk.getClass(this.getClassName(target))
  }

  static getClassName(target) {
    if (target == null) {
      return 'Null'
    } else if (typeof(target) == 'number') {
      return 'Int'
    } else if (typeof(target) == 'boolean') {
      return 'Bool'
    } else if (_toString.call(target) == '[object Array]') {
      return 'Array'
    } else if (_toString.call(target) == '[object String]') {
      return 'String'
    } else if (target.__name == null) {
      return target.name // temp
    }
    // todo: more primitive checks
    return target.__name
  }

  static getSuperclass(target) {
    var cls = this.getClass(target)
    if (cls) return cls.__super
  }

  static is(a, b) {
    var passing = this.getClassName(a) == this.getClassName(b)
    if (passing != true) {
      var superclass = this.getSuperclass(a)
      if (superclass == null) return false
      return this.is(superclass, b)
    }
    return passing
  }

  static getMethod(target, name) {
    var f = target[name]
    if (f && f.bind) {
      return f.bind(target)
    }
    return f
  }

  static getMethodNames(target) {
    var cls = this.getClass(target)
    if (cls == null) return []
    return Object.getOwnPropertyNames(cls.prototype) 
  }

  static getConstructor(target, name) {
    var cls = this.getClass(target)
    var c = cls[name]
    if (c && c.bind) {
      return c.bind(cls)
    }
    return c
  }

  static getConstructorNames(target) {
    return __quirk.getConstructors(this.getClassName(target))
  }

  static setField(target, name, value) {
    target[name] = value
  }

  static getField(target, name) {
    return target[name]
  }

  static getFieldNames(target) {
    return Object.keys(target)
  }

  static callFunction(f, context, args) {
    return f.apply(context, args)
  }

  static isArray(target) {
    return _toString.call(target) == '[object Array]'
  }

  static isFunction(target) {
    return typeof(target) == 'function'
  }

  static isString(target) {
    return typeof(target) == 'string'
  }

  static isObject(target) {
    return typeof(target) == 'object'
  }

  static isInt(target) {
    return typeof(target) == 'number'
  }

  static isNull(target) {
    return target == null
  }

}

class Meta {
  
  static getFields(target) {
    var name = Reflect.getClassName(target)
    var sup = Reflect.getSuperclass(target)
    var meta = __quirk.meta[name]
    
    if (meta == null) meta = {}
    if (sup != null) {
      var supMeta = this.getFields(sup)
      Reflect.getFieldNames(supMeta).forEach {
        if (meta[it] != null) {
          meta[it] = meta[it].concat(supMeta[it])
        } else {
          meta[it] = supMeta[it]
        }
      }
    }

    return meta
  }

  static getType(target) {
    return this.getFields(target).__TYPE__
  }

}

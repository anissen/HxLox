module Test.Std.Mirror for ReflectTest, MetaTest

import Std.Test for Case
import Std.Mirror for Reflect, Meta

class ReflectFixture {
  
  construct new(a) {
    this.a = a
  }

  construct defaults() {
    this.new('a')
  }

}

class ReflectTest : Case {

  construct new() {
    super.new()
  }
  
  @test('Gets the correct type name')
  testGetType() {
    this.assertEquals(Reflect.getClassName(ReflectTest), 'Test.Std.Mirror.ReflectTest');
  }

  @test('Compares classes correctly')
  testIs() {
    this.assertTrue(Reflect.is(ReflectTest, ReflectTest));
    this.assertTrue(Reflect.is(ReflectTest, Case));
    this.assertFalse(Reflect.is(ReflectTest, String));
  }

  @test('Gets constructor names')
  testGetConstructors() {
    this.assertEquals(
      Reflect.getConstructorNames(ReflectFixture).join(','),
      'new,defaults'
    ) 
  }

  @test('Gets the class names of primitives')
  testGetPrimitiveNames() {
    this.assertEquals(Reflect.getClassName(1), Reflect.getClassName(Int))
    this.assertEquals(Reflect.getClassName(false), Reflect.getClassName(Bool))
    this.assertEquals(Reflect.getClassName(true), Reflect.getClassName(Bool))
    this.assertEquals(Reflect.getClassName(null), 'Null')
  }

  @test('Compares primitives correctly')
  testComparePrimitives() {
    this.assertTrue(Reflect.is(true, Bool))
    this.assertTrue(Reflect.is('foo', String))
    //this.assertTrue(Reflect.is(1, Int))
  }

  @test('Calls constructors correctly')
  testCallConstructors() {
    var def = Reflect.getConstructor(ReflectFixture, 'defaults')
    this.assertEquals(def().a, 'a')
    this.assertTrue(Reflect.is(def(), ReflectFixture))
    
    var nu = Reflect.getConstructor(ReflectFixture, 'new')
    this.assertEquals(nu('b').a, 'b')
    this.assertTrue(Reflect.is(nu('b'), ReflectFixture))
  }

  @test('Sets and gets fields')
  testSetAndGetField() {
    var a = { a: 'aye' }
    Reflect.setField(a, 'b', 'bee')
    this.assertEquals(Reflect.getField(a, 'a'), 'aye')
    this.assertEquals(Reflect.getField(a, 'b'), 'bee')
    this.assertEquals(Reflect.getField(a, 'c'), null)
  }

}

@foo
@bar('value')
class MetaFixture {

}

@bin
class MetaInheritedFixture : MetaFixture {

}

class MetaTest : Case {
  
  construct new() {
    super.new()
  }

  @test('Gets metadata for types')
  testTypeMeta() {
    Meta.getType(MetaFixture).forEach {
      if (it.name == 'foo') {
        this.assertEquals(it.values.length, 0)
      } else {
        this.assertEquals(it.name, 'bar')
        this.assertEquals(it.values[0], 'value')
      }
    }
  }

  @test('Gets inherited metadata')
  testInheritance() {
    var meta = Meta.getType(MetaInheritedFixture)
    var foo = meta.find { it.name == 'foo' }
    var bar = meta.find { it.name == 'bar' }
    var bin = meta.find { it.name == 'bin' }
    this.assertEquals(meta.length, 3)
    this.assertTrue(foo != null)
    this.assertTrue(bar != null)
    this.assertTrue(bin != null)
  }

}
